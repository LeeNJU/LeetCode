#include<vector>
//题目描述:给定一个数字n，把[1,n]范围内的数字进行字典排序,例如n=13,结果为[1,10,11,12,13,2,3,4,5,6,7,8,9].
//解法描述:简单解法是把所有数字转换成字符串，然后直接进行排序，但是复杂度太高。一种解法是从1开始，开始加0，因为
//        加0肯定是最小的，直到不能再加0，就依次加1，不过要注意，如果当前数字大于等于n的话，就要除以10然后再加
//        1, 例如当前数字是13，不能再继续加1了，除以10再加1，得到2，然后从而开始。如果加1之后，末尾有0，必须
//        处理掉末尾的0，然后再开始。
 
std::vector<int> lexicalOrder(int n) 
{
	std::vector<int> result(n);
	int cur = 1;
	for (int i = 0; i < n; ++i)
	{
		result[i] = cur;
		if (cur * 10 <= n) //往数字后面加0，因为加0总是最小的
			cur *= 10;
		else 
		{
			if (cur >= n) //个位已经不能再加了，从十位开始加
				cur /= 10;
			cur += 1;
			while (cur % 10 == 0) //去掉末尾的0
				cur /= 10;
		}
	}
	return result;
}